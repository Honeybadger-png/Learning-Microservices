The title came from request.body and the title on the ticket isnt the same. We can do some validation or sanitization on these values. SO the value that came in off the request body is not necessarily the same as what actually got save to the database.So it is recommended pulling the title or all these relevant attributes directly off of the ticket that we just saved to the database.

We enter creating a cyclical dependecy circle we will solve it with building something very similar to Mongoose, where we're going to have some kind of object that internally keeps track of some client and makes it available to everything else inside of our app. The index file is then going to import that and make sure that we have some code inside there to actually initialize that we have some code inside there to actually initialize that NATS cliend and connect to NATS streaming server.

We use mongoose technically through the ticket model but we could technically import Mongoose and use it to reach directly out to our database without having to worry about initializing any connection or anything like that. We want to do something very similar with this NATS client that we are putting together.

The goal of this NATS wrapper class is to create and intialize a client from the stand or the NATS library. NO NATS streaming. Then rather than exporting the entire class, we're going to create an instance of that class inside this file and export that instance. So we will then be able to access the same object, the same instance inside of indexes and inside of the ticket created route handler. So just like Mongoose, we can initialize or we will be able to initialize this client from inside of indexes. and then by the time our ticket created root handler accesses or import this thing, the client will have already been initialized.

Ts Error - Did you forget to include 'void' in your type argument:
- In the upcoming lecture, we will be returning a promise in our natsWrapper class. A small update is required to deal with a TS error you will see: Expected 1 arguments, but got 0. Did you forget to include 'void' in your type argument to 'Promise'?
In src/nats-wrapper.ts, we just need to add the void type to the Promise: 
return new Promise<void> ...
One of the arguments we provided was "-cid" and we gave it a value of ticketing. cid stands for cluster ID. This is going to assign an ID to the cluster and in the case the ID is simply ticketing. Thats what the first argument is. We're just specifying the ID of the cluster that we're trying to connect to.

We need to somehow expose the client(client in the nats-wrapper file) to the outside world, but just keep in mind that this client thing might at some point in times be undefined. So i want to expose this to outside people, but i also want to somehow throw in air or something bery similar to that.

We used getter in the nats-wrapper to expose the ("_client?: Stan")

We make sure to attempt to capture any close event. And once we capture it, we're going to make sure we do a console.log say hey everything was shut down successfully and then exit. And we also set up two listeners on the process to make sure theres ever an interrupt or a terminate. We are going to go ahead and close eveything down.

1- get a listing of all my pods
2- Im going to find the pod running nats and then do a cube ctl, delete pod and then put in the name of that pod.

My test are currently failing cause of natswrapper import. So we will let jest kinda  to redirect that import request and JEST will create a Fake NatsWrapper we need to make it look like real import but it will be FAKE!!

Here is the process what we are going to make:
Mocking (Faking) Imports with Jest
- Find the file that we want to 'fake'
- In the same directory, create a folder called '__mocks__'
- In that folder, create a file with an identical name to the file we want to fake
- Write a fake implementation
- Tell jest to use that fake file in our test file

Instead of providing fake implementation we are going to instead provide mock function that will provide us to make test around function. We will use jest.fn() but we also need to provide mock implementation too so we chain it with mockImplementation function.

NATS env variables: 
pods names are unique and using the pod name can be very useful so how can we do that:
- inside of our tickets-depl.yaml file in env section we add another entry we provide NATS_CLIENT_ID for the value we somehow need to tell kubernetes we want to get pod's name which is randomly generated by kubernetes. So we write valueFrom -> fieldRed -> fieldPath : metadata.name
