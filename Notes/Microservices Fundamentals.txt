Communication Strategies between services

Sync : Service communicate with each other using direct requests
Async : Services communicate with each other using events

Sync Communication: It is easy to use but there is still problems with dependency between services. If one crash it can effects the service.
Also the entire request is only as fast as the slowest request

Event Based Communication: request event send by event bus and the response data also created with event and send with event bus. Same problems in sync communication occur.

Kubernetes cluster : A collections of nodes + a master to manage them
Node : A virtual machine that will run our containers
Pod : More or less a running container. Techincally, a pod can run multiple containers ( we won't do this)
Deployman : Monitors a set of pods, make sure they are running and restarts them if they crash
Service : Provides an easy-to-remember URL to access a running container

**Kubernetes Config Files**
- Tells kubernetes about the different deployments,Pods, and Services (referred to as 'Objects') that we want to created
- Written in YAML syntax
- Always store these files with our project source code - they are documentation!
- We can create Objects without config files - do not do this. Config files provide a precise definition of what your cluster is running
 - Kubernetes docs will tell you to run direct commands to create objects - only do this for testing purposes
 - Blog posts will tell you to run direct commands to create objects - close the blog post

I had a ImagePullBackOff status in my pods. I had to delete pod with kubectl delete -f infra/k8s/ commands
then update the manifest by adding imagePullPolicy: Never 
after that error i have got ErrImageNeverPull error and I solved it:
docker build -t mertg/posts:0.0.1 . 
docker tag mertg/posts:0.0.1 mertg/posts:0.0.1
kubectl apply -f infra/k8s/
kubectl get pods 

solved my error.

Understanding pod spec:
- apiVersion: v1 = K8s is extensible - we can add in our own custom objects. This specifies the set of objects we want K8s to look at
- kind: Pod = The type of object we want to create
- metadata: = Config options for the object we are about to create
 - name: posts = when the pod is created give it a name of 'posts'
- spec: = the exact attributes we want to apply to the object we are about to create
 -containers: = we can create many containers in a single pod
  - - name:posts = Make a container with a name of 'posts'
  - image: mertg/posts:0.0.1  = the exact image we want to use

Deployment: instead of creating pods directly we will usually use deployment.
if pods crashes deployment will automatically create that pod for us.

Updating the Image Used By a Deployment - Method #1
- Make a change to your project code
- rebuild the image, specifying a new image version
- In the deployment config file update the version of the image
- Run the command 
- kubectl apply -f [depl file name]

Updating the Image Used By a Deployment - Method #2
- The deployment must be using 'latest' tag in the pod spec section
- make an update to your code 
- Build the image
- Push the image to docker hub
- Run the command kubectl rollout restart deployment [depl_name]

Types of Services
- *Cluster IP : Sets up an easy-to-remember URL to access a pod. Only exposes pods in the cluster.
- Node Port : Makes a pod accessible from outside the cluster. Usually only used for dev purposes
- *Load Balancer : Makes a pod accessible from outside the cluster. This is the right way to expose a pod to the outside world.
- External Name : Redirects an in-cluster request to a CNAME url ......... don't worry about this one....

Creating a NodePort Service
we will write config for posts-srv.yaml file.
we use selector inside of posts-srv in the purpose of find the pods that has posts label.
we can get nodePort by kubectl get services
Docker for Mac/Windows -> localhost:3xxxx/posts
Docker Toolbox with Minikube -> <some_ip>:3xxxx/posts